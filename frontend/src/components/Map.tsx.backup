import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { Spot, api } from '../api';
import { useMapInstance } from './Map/hooks/useMapInstance';
import { useMarkerManager } from './Map/hooks/useMarkerManager';
import { useOverlayManager } from './Map/hooks/useOverlayManager';
import { useRouteManager } from './Map/hooks/useRouteManager';
import { usePopulationOverlay } from './Map/hooks/usePopulationOverlay';
import { useContextMenu } from './Map/hooks/useContextMenu';
import { useLocationManager } from './Map/hooks/useLocationManager';
import { useMapData } from './Map/hooks/useMapData';
import { usePerformanceMonitor } from './Map/hooks/usePerformanceMonitor';
import PinRegistrationModal from './PinRegistrationModal';
import Alert from './Alert';
import PlacePopulation from './Map/PlacePopulation';
import { useLoading } from '../contexts/LoadingContext';

interface MapProps {
  places: Spot[];
  onPlaceClick?: (place: Spot) => void;
  selectedSpot?: Spot | null;
  onSpotsUpdate?: () => void;
  onSpotDelete?: (spotId: string) => void;
}

const Map: React.FC<MapProps> = React.memo(({
  places,
  onPlaceClick,
  selectedSpot,
  onSpotsUpdate,
  onSpotDelete
}) => {
  console.log('üó∫Ô∏è OptimizedMap Î†åÎçîÎßÅ - places Ïàò:', places?.length || 0);

  const mapRef = useRef<HTMLDivElement>(null);
  const [showCongestion, setShowCongestion] = useState(true);
  const [showPinModal, setShowPinModal] = useState(false);
  const [pinModalData, setPinModalData] = useState({ lat: 0, lng: 0 });
  const [nearbyQuietPlaces, setNearbyQuietPlaces] = useState<Spot[]>([]);
  const [alert, setAlert] = useState<{
    isOpen: boolean;
    type: 'success' | 'error';
    message: string;
  }>({
    isOpen: false,
    type: 'success',
    message: ''
  });

  const { withLoading } = useLoading();
  const { startRender, endRender } = usePerformanceMonitor('Map');

  // Initialize map instance
  const mapOptions = useMemo(() => ({
    center: { lat: 37.5665, lng: 126.9780 },
    level: 8
  }), []);

  const {
    mapInstance,
    initializeMap,
    panTo,
    setLevel,
    relayout
  } = useMapInstance(mapRef);

  // Initialize data management
  const {
    populationData,
    loadPopulationData
  } = useMapData();

  // Alert management
  const showAlert = useCallback((type: 'success' | 'error', message: string) => {
    setAlert({ isOpen: true, type, message });
  }, []);

  const closeAlert = useCallback(() => {
    setAlert(prev => ({ ...prev, isOpen: false }));
  }, []);

  // Initialize managers with callbacks
  const overlayCallbacks = useMemo(() => ({
    onSpotDelete,
    onAlert: showAlert
  }), [onSpotDelete, showAlert]);

  const routeCallbacks = useMemo(() => ({
    onAlert: showAlert
  }), [showAlert]);

  const {
    updateMarkers,
    highlightMarkers,
    getMarkerByPlaceId
  } = useMarkerManager(mapInstance);

  const {
    showInfoWindow
  } = useOverlayManager(mapInstance, overlayCallbacks);

  const {
    routeState,
    setStartPoint,
    setEndPoint,
    addWaypoint,
    clearRoute,
    findNearbyQuietPlaces
  } = useRouteManager(mapInstance, routeCallbacks);

  const {
    updateOverlays
  } = usePopulationOverlay(mapInstance);

  const {
    moveToCurrentLocation,
    isLocating
  } = useLocationManager(mapInstance);

  // Context menu actions
  const contextMenuActions = useMemo(() => ({
    onRegisterPin: (lat: number, lng: number) => {
      setPinModalData({ lat, lng });
      setShowPinModal(true);
    },
    onSetStartPoint: setStartPoint,
    onSetEndPoint: setEndPoint,
    onAddWaypoint: addWaypoint,
    onClearRoute: clearRoute
  }), [setStartPoint, setEndPoint, addWaypoint, clearRoute]);

  const { contextMenu, handleContextMenuAction } = useContextMenu(
    mapRef,
    mapInstance,
    contextMenuActions
  );

  // Optimized marker click handler
  const handleMarkerClick = useCallback((place: Spot) => {
    showInfoWindow(place);
    panTo(place.lat, place.lng);
    setTimeout(() => setLevel(3), 300);
    onPlaceClick?.(place);
  }, [showInfoWindow, panTo, setLevel, onPlaceClick]);

  // Optimized spot movement
  const moveToSpot = useCallback((spot: Spot) => {
    const currentLevel = mapInstance?.getLevel() || 8;
    const targetLevel = 3;

    if (currentLevel > 5) {
      panTo(spot.lat, spot.lng);
      setTimeout(() => setLevel(targetLevel), 300);
    } else {
      panTo(spot.lat, spot.lng);
      setTimeout(() => {
        if (mapInstance?.getLevel() !== targetLevel) {
          setLevel(targetLevel);
        }
      }, 300);
    }

    setTimeout(() => relayout(), 100);
  }, [mapInstance, panTo, setLevel, relayout]);

  // Pin registration handler
  const handlePinRegistration = useCallback(async (data: {
    name: string;
    description: string;
    category: string;
    noiseLevel: number;
    rating: number;
    image_url?: string;
    isNoiseRecorded: boolean;
  }) => {
    try {
      await withLoading(async () => {
        const quietRating = Math.max(10, Math.min(100, 100 - (data.noiseLevel - 20) * 1.5));
        const currentUser = api.auth.getCurrentUser();
        
        const spotData = {
          name: data.name,
          description: data.description,
          lat: pinModalData.lat,
          lng: pinModalData.lng,
          category: data.category,
          noise_level: data.noiseLevel,
          rating: data.rating,
          quiet_rating: Math.round(quietRating),
          is_noise_recorded: data.isNoiseRecorded,
          user_id: currentUser ? currentUser.id : 'anonymous',
          image_url: data.image_url || undefined
        };

        return await api.spots.createSpot(spotData);
      }, 'ÏâøÌîåÎ†àÏù¥Ïä§ Îì±Î°ù Ï§ë...');

      setShowPinModal(false);
      onSpotsUpdate?.();
    } catch (error) {
      console.error('Ïä§Ìåü Îì±Î°ù Ïã§Ìå®:', error);
      showAlert('error', 'Ïä§Ìåü Îì±Î°ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
    }
  }, [pinModalData, withLoading, onSpotsUpdate, showAlert]);

  // Initialize map
  useEffect(() => {
    startRender();
    if (mapRef.current && window.kakao?.maps) {
      initializeMap(mapOptions);
      setTimeout(() => loadPopulationData(), 1000);
    }
    endRender(places.length, populationData.length);
  }, [initializeMap, mapOptions, loadPopulationData, startRender, endRender, places.length, populationData.length]);

  // Update markers when places change
  useEffect(() => {
    if (mapInstance && places.length > 0) {
      startRender();
      updateMarkers(places, handleMarkerClick);
      endRender(places.length, 0);
    }
  }, [mapInstance, places, updateMarkers, handleMarkerClick, startRender, endRender]);

  // Update population overlays
  useEffect(() => {
    if (mapInstance && populationData.length > 0) {
      updateOverlays(populationData, showCongestion);
    }
  }, [mapInstance, populationData, showCongestion, updateOverlays]);

  // Handle selected spot
  useEffect(() => {
    if (selectedSpot && mapInstance) {
      const marker = getMarkerByPlaceId(selectedSpot.id);
      if (marker) {
        showInfoWindow(selectedSpot);
      }
    }
  }, [selectedSpot, mapInstance, getMarkerByPlaceId, showInfoWindow]);

  // Update nearby places when route changes
  useEffect(() => {
    if (routeState.recommendedRoute?.points && places.length > 0) {
      const nearbyPlaces = findNearbyQuietPlaces(
        routeState.recommendedRoute.points,
        places,
        300
      );
      setNearbyQuietPlaces(nearbyPlaces);
      
      if (nearbyPlaces.length > 0) {
        highlightMarkers(nearbyPlaces.map(p => p.id));
      }
    } else {
      setNearbyQuietPlaces([]);
    }
  }, [routeState.recommendedRoute, places, findNearbyQuietPlaces, highlightMarkers]);

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      <div id="map" ref={mapRef} style={{ width: '100%', height: '100%' }} />

      {/* Context Menu */}
      {contextMenu.visible && (
        <div
          style={{
            position: 'fixed',
            left: contextMenu.x,
            top: contextMenu.y,
            background: 'white',
            border: '1px solid #ccc',
            borderRadius: '8px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
            zIndex: 2000,
            minWidth: '120px',
            overflow: 'hidden'
          }}
          onClick={(e) => e.stopPropagation()}
        >
          {[
            { action: 'register', label: 'üìç ÌïÄ Îì±Î°ù' },
            { action: 'start', label: 'üöÄ Ï∂úÎ∞úÏßÄ' },
            { action: 'waypoint', label: 'üîÑ Í≤ΩÏú†ÏßÄ' },
            { action: 'end', label: 'üèÅ ÎèÑÏ∞©ÏßÄ' },
            { action: 'clear-route', label: 'üóëÔ∏è Í≤ΩÎ°ú ÏßÄÏö∞Í∏∞' }
          ].map(({ action, label }, index, array) => (
            <div
              key={action}
              style={{
                padding: '8px 12px',
                cursor: 'pointer',
                borderBottom: index < array.length - 1 ? '1px solid #eee' : 'none',
                fontSize: '14px'
              }}
              onClick={() => handleContextMenuAction(action)}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
            >
              {label}
            </div>
          ))}
        </div>
      )}

      {/* Current Location Button */}
      <button
        onClick={moveToCurrentLocation}
        disabled={isLocating}
        style={{
          position: 'absolute',
          bottom: '20px',
          right: '20px',
          width: '50px',
          height: '50px',
          borderRadius: '50%',
          border: 'none',
          backgroundColor: '#fff',
          boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
          cursor: isLocating ? 'not-allowed' : 'pointer',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: '20px',
          zIndex: 1000,
          opacity: isLocating ? 0.6 : 1,
          transition: 'all 0.2s ease'
        }}
        title="ÎÇ¥ ÏúÑÏπòÎ°ú Ïù¥Îèô"
      >
        {isLocating ? '‚è≥' : 'üìç'}
      </button>

      {/* Congestion Toggle */}
      <div style={{
        position: 'absolute',
        top: '20px',
        right: '20px',
        zIndex: 1000
      }}>
        <button
          onClick={() => setShowCongestion(!showCongestion)}
          style={{
            padding: '10px 15px',
            backgroundColor: showCongestion ? '#FF6B35' : '#fff',
            color: showCongestion ? '#fff' : '#333',
            border: '1px solid #ccc',
            borderRadius: '6px',
            fontSize: '14px',
            fontWeight: 'bold',
            cursor: 'pointer',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
            minWidth: '100px'
          }}
        >
          Ïã§ÏãúÍ∞Ñ ÌòºÏû°ÎèÑ {showCongestion ? 'ON' : 'OFF'}
        </button>
      </div>

  const moveToSpot = (spot: Spot) => {
    if (!mapInstance.current) return;

    const moveLatLng = new (window as any).kakao.maps.LatLng(spot.lat, spot.lng);
    const currentLevel = mapInstance.current.getLevel();
    const targetLevel = 3;

    // Ï§å ÏïÑÏõÉ ÏÉÅÌÉúÏóêÏÑúÎäî Î®ºÏ†Ä Ï§ëÏã¨ÏúºÎ°ú Ïù¥Îèô ÌõÑ Ï§åÏù∏
    if (currentLevel > 5) {
      mapInstance.current.panTo(moveLatLng);
      setTimeout(() => {
        if (mapInstance.current) {
          mapInstance.current.setLevel(targetLevel);
        }
      }, 300);
    } else {
      // ÏùºÎ∞ò Ï§å Î†àÎ≤®ÏóêÏÑúÎäî Î∂ÄÎìúÎü¨Ïö¥ Ïù¥Îèô
      mapInstance.current.panTo(moveLatLng);
      setTimeout(() => {
        if (mapInstance.current && mapInstance.current.getLevel() !== targetLevel) {
          mapInstance.current.setLevel(targetLevel);
        }
      }, 300);
    }

    setTimeout(() => {
      if (mapInstance.current) {
        mapInstance.current.relayout();
      }
    }, 100);
  };

  const getCrowdColor = (crowdLevel: number) => {
    // ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏÉâÏó∞ÌïÑ ÏÉâÍ∞ê
    if (crowdLevel >= 80) return '#FF6B6B';      // Ïó∞Ìïú Îπ®Í∞ÑÏÉâ
    if (crowdLevel >= 60) return '#FFB347';      // Ïó∞Ìïú Ï£ºÌô©ÏÉâ
    if (crowdLevel >= 40) return '#FFE66D';      // Ïó∞Ìïú ÎÖ∏ÎûÄÏÉâ
    if (crowdLevel >= 20) return '#95E1D3';      // Ïó∞Ìïú ÎØºÌä∏ÏÉâ
    return '#A8E6CF';                            // Ïó∞Ìïú ÎÖπÏÉâ
  };

  const getNoiseColor = (noiseLevel: number) => {
    // ÏÜåÏùåÎ†àÎ≤®Ïö© ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏÉâÍ∞ê
    if (noiseLevel >= 70) return '#FF8A95';      // Ïó∞Ìïú Î∂ÑÌôçÏÉâ
    if (noiseLevel >= 50) return '#FECA57';      // Ïó∞Ìïú Ìô©Í∏àÏÉâ
    if (noiseLevel >= 30) return '#48CAE4';      // Ïó∞Ìïú ÌïòÎäòÏÉâ
    return '#B8E6B8';                            // Ïó∞Ìïú Ïó∞ÎëêÏÉâ
  };

  const createNaturalCircles = (latitude: number, longitude: number, color: string, intensity: number): any[] => {
    const circles: any[] = [];
    const center = new (window as any).kakao.maps.LatLng(latitude, longitude);

    // Îã§Ï§ë ÏõêÌòïÏúºÎ°ú ÏûêÏó∞Ïä§Îü¨Ïö¥ Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìö®Í≥º ÏÉùÏÑ±
    const layers = [
      { radius: 100, opacity: Math.min(0.6, intensity / 100 * 0.6) },
      { radius: 200, opacity: Math.min(0.4, intensity / 100 * 0.4) },
      { radius: 300, opacity: Math.min(0.2, intensity / 100 * 0.2) },
      { radius: 400, opacity: Math.min(0.1, intensity / 100 * 0.1) }
    ];

    layers.forEach(layer => {
      const circle = new (window as any).kakao.maps.Circle({
        center: center,
        radius: layer.radius,
        strokeWeight: 0,
        fillColor: color,
        fillOpacity: layer.opacity
      });

      circle.setMap(mapInstance.current);
      circles.push(circle);
    });

    return circles;
  };

  const updateCrowdPolygons = () => {
    // Í∏∞Ï°¥ Ìè¥Î¶¨Í≥§ Ï†úÍ±∞
    crowdPolygonsRef.current.forEach(polygon => polygon.setMap(null));
    crowdPolygonsRef.current = [];

    if (!mapInstance.current || !populationData.length) return;

    populationData.forEach((data: any) => {
      const latitude = data.lat;
      const longitude = data.lng;

      if (!latitude || !longitude) {
        console.warn('ÏúÑÎèÑ/Í≤ΩÎèÑ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§:', data);
        return;
      }

      const crowdLevel = data.crowdLevel || data.crowd_level || 50;
      const color = getCrowdColor(crowdLevel);

      // Ìò∏Î≤ÑÏö© Ìà¨Î™Ö ÏõêÌòï ÏòÅÏó≠
      const hoverCircle = new (window as any).kakao.maps.Circle({
        center: new (window as any).kakao.maps.LatLng(latitude, longitude),
        radius: 400,
        strokeWeight: 0,
        fillColor: 'transparent',
        fillOpacity: 0
      });

      hoverCircle.setMap(mapInstance.current);

      // Ìò∏Î≤Ñ Ïù¥Î≤§Ìä∏
      (window as any).kakao.maps.event.addListener(hoverCircle, 'mouseover', () => {
        const content = `
          <div style="padding: 12px; font-size: 14px; background: white; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); border: 1px solid #ddd; max-width: 220px;">
            <strong style="color: #333;">üìç ${data.name || 'ÏúÑÏπòÏ†ïÎ≥¥'}</strong><br>
            <strong style="color: #333;">üö∂ Ïú†ÎèôÏù∏Íµ¨: ${data.population?.toLocaleString() || 'Ï†ïÎ≥¥ÏóÜÏùå'}Î™Ö</strong><br>
            <strong style="color: #666;">üìä ÌòºÏû°ÎèÑ: ${crowdLevel}%</strong><br>
            <div style="margin-top: 8px; padding: 4px 8px; background: ${color}; border-radius: 4px; font-size: 12px;">
              ${crowdLevel >= 80 ? 'üî¥ Îß§Ïö∞ ÌòºÏû°' : crowdLevel >= 60 ? 'üü† ÌòºÏû°' : crowdLevel >= 40 ? 'üü° Î≥¥ÌÜµ' : crowdLevel >= 20 ? 'üü¢ Ïó¨Ïú†' : 'üîµ ÌïúÏ†Å'}
            </div>
          </div>
        `;

        const tempInfoWindow = new (window as any).kakao.maps.InfoWindow({
          content: content,
          removable: false
        });

        tempInfoWindow.open(mapInstance.current, new (window as any).kakao.maps.LatLng(latitude, longitude));

        (window as any).kakao.maps.event.addListener(hoverCircle, 'mouseout', () => {
          tempInfoWindow.close();
        });
      });

      crowdPolygonsRef.current.push(hoverCircle);
    });
  };

  const updateNoiseCircles = () => {
    // Í∏∞Ï°¥ ÏõêÌòï Ï†úÍ±∞
    noiseCirclesRef.current.forEach(circle => circle.setMap(null));
    noiseCirclesRef.current = [];

    if (!mapInstance.current || !populationData.length) return;

    populationData.forEach((data: any) => {
      const latitude = data.lat;
      const longitude = data.lng;

      if (!latitude || !longitude) {
        console.warn('ÏúÑÎèÑ/Í≤ΩÎèÑ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§:', data);
        return;
      }

      const noiseLevel = data.noiseLevel || data.noise_level || 40;
      const color = getNoiseColor(noiseLevel);

      // ÏÜåÏùåÎ†àÎ≤®ÏùÑ ÏûëÏùÄ Îã§Ï§ë ÏõêÌòïÏúºÎ°ú ÌëúÏãú
      const circles = createNaturalCircles(latitude, longitude, color, noiseLevel);

      // ÏÜåÏùåÎ†àÎ≤®ÏùÄ Îçî ÏûëÏùÄ ÌÅ¨Í∏∞Î°ú Ï°∞Ï†ï
      circles.forEach((circle, index) => {
        const smallRadius = [60, 120, 180, 240][index]; // Îçî ÏûëÏùÄ Î∞òÍ≤Ω
        circle.setRadius(smallRadius);
      });

      circles.forEach(circle => noiseCirclesRef.current.push(circle));
    });
  };

  const updateMarkers = () => {
    markersRef.current.forEach(marker => marker.setMap(null));
    markersRef.current = [];
    markersPlacesRef.current = [];

    places.forEach(place => {
      const position = new (window as any).kakao.maps.LatLng(place.lat, place.lng);
      const markerIcon = createMarkerIcon(place.category || 'Í∏∞ÌÉÄ');

      const marker = new (window as any).kakao.maps.Marker({
        position,
        map: mapInstance.current,
        image: markerIcon
      });

      (window as any).kakao.maps.event.addListener(marker, 'click', () => {
        // InfoWindow ÌëúÏãú
        showInfoWindow(marker, place);

        // ÏßÄÎèÑ Ï§ëÏã¨ÏùÑ Ìï¥Îãπ ÏúÑÏπòÎ°ú Ïù¥Îèô
        moveToSpot(place);

        // Ïô∏Î∂Ä ÏΩúÎ∞± Ìò∏Ï∂ú
        onPlaceClick?.(place);
      });

      markersRef.current.push(marker);
      markersPlacesRef.current.push(place);
    });
  };

  const addCurrentLocationMarker = (lat: number, lng: number) => {
    if (!mapInstance.current) return;

    if (currentLocationMarkerRef.current) {
      currentLocationMarkerRef.current.setMap(null);
    }

    const position = new (window as any).kakao.maps.LatLng(lat, lng);

    const imageSrc = 'data:image/svg+xml;base64,' + btoa(`
      <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="#FF0000">
        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
      </svg>
    `);

    const imageSize = new (window as any).kakao.maps.Size(32, 32);
    const markerImage = new (window as any).kakao.maps.MarkerImage(imageSrc, imageSize);

    currentLocationMarkerRef.current = new (window as any).kakao.maps.Marker({
      position,
      image: markerImage,
      map: mapInstance.current
    });
  };

  const moveToCurrentLocation = () => {
    if (!navigator.geolocation) {
      window.alert('ÏúÑÏπò ÏÑúÎπÑÏä§Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∏åÎùºÏö∞Ï†ÄÏûÖÎãàÎã§.');
      return;
    }

    setIsLocating(true);

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        const moveLatLng = new (window as any).kakao.maps.LatLng(latitude, longitude);

        if (mapInstance.current) {
          // Î∂ÄÎìúÎü¨Ïö¥ Ïï†ÎãàÎ©îÏù¥ÏÖòÏúºÎ°ú Ïù¥Îèô
          mapInstance.current.panTo(moveLatLng);

          // Ï§å Î†àÎ≤®ÎèÑ Î∂ÄÎìúÎüΩÍ≤å Î≥ÄÍ≤Ω
          setTimeout(() => {
            if (mapInstance.current && mapInstance.current.getLevel() !== 3) {
              mapInstance.current.setLevel(3);
            }
          }, 300);

          addCurrentLocationMarker(latitude, longitude);
        }

        setIsLocating(false);
      },
      (error) => {
        console.error('ÏúÑÏπò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§:', error);
        window.alert('ÏúÑÏπò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. ÏúÑÏπò Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
        setIsLocating(false);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 300000
      }
    );
  };

  const handleContextMenuAction = (action: string) => {
    const { lat, lng } = contextMenu;

    switch (action) {
      case 'register':
        setPinModalData({ lat, lng });
        setShowPinModal(true);
        break;
      case 'start':
        clearRoute();
        const startPoint = { lat, lng };
        startPointRef.current = startPoint;
        isRouteModeRef.current = true;
        setRouteState(prev => ({
          ...prev,
          startPoint,
          isRouteMode: true
        }));
        addRouteMarker(lat, lng, 'start');
        console.log('Ï∂úÎ∞úÏßÄ ÏÑ§Ï†ï:', startPoint);
        showAlert('success', 'üöÄ Ï∂úÎ∞úÏßÄÍ∞Ä ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§. ÎèÑÏ∞©ÏßÄÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
        break;
      case 'end':
        if (!startPointRef.current) {
          showAlert('error', 'Î®ºÏ†Ä Ï∂úÎ∞úÏßÄÎ•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.');
          break;
        }
        const endPoint = { lat, lng };
        endPointRef.current = endPoint;
        setRouteState(prev => ({
          ...prev,
          endPoint
        }));
        addRouteMarker(lat, lng, 'end');
        console.log('ÎèÑÏ∞©ÏßÄ ÏÑ§Ï†ï:', endPoint);
        console.log('ü§´ Ï°∞Ïö©Ìïú Í≤ΩÎ°ú ÌÉêÏÉâ ÏãúÏûë:', startPointRef.current, '‚Üí', endPoint);
        drawQuietRoute(startPointRef.current, endPoint, waypointsRef.current);
        break;
      case 'clear-route':
        clearRoute();
        break;
      case 'waypoint':
        if (!startPointRef.current) {
          showAlert('error', 'Î®ºÏ†Ä Ï∂úÎ∞úÏßÄÎ•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.');
          break;
        }
        const waypoint = { lat, lng };
        waypointsRef.current.push(waypoint);
        addRouteMarker(lat, lng, 'waypoint');
        console.log('Í≤ΩÏú†ÏßÄ Ï∂îÍ∞Ä:', waypoint);
        showAlert('success', `üìç Í≤ΩÏú†ÏßÄ ${waypointsRef.current.length}Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`);
        break;
    }

    setContextMenu(prev => ({ ...prev, visible: false }));
  };

  // UTF-8 Î¨∏ÏûêÏó¥ÏùÑ Base64Î°ú ÏïàÏ†ÑÌïòÍ≤å Ïù∏ÏΩîÎî©ÌïòÎäî Ìï®Ïàò
  const utf8ToBase64 = (str: string) => {
    return btoa(unescape(encodeURIComponent(str)));
  };

  const addRouteMarker = (lat: number, lng: number, type: 'start' | 'end' | 'waypoint') => {
    if (!mapInstance.current) {
      console.error('ÏßÄÎèÑ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä ÏóÜÏäµÎãàÎã§');
      return;
    }

    console.log(`${type} ÎßàÏª§ Ï∂îÍ∞Ä Ï§ë:`, lat, lng);

    const position = new (window as any).kakao.maps.LatLng(lat, lng);

    let markerSvg = '';

    switch (type) {
      case 'start':
        markerSvg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="48" height="60" viewBox="0 0 48 60">
            <defs>
              <linearGradient id="startGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#66BB6A;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#2E7D32;stop-opacity:1" />
              </linearGradient>
              <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="4" stdDeviation="4" flood-color="rgba(0,0,0,0.3)"/>
              </filter>
            </defs>
            <path d="M24 0C15.163 0 8 7.163 8 16c0 12 16 28 16 28s16-16 16-28c0-8.837-7.163-16-16-16z" 
                  fill="url(#startGradient)" filter="url(#shadow)"/>
            <circle cx="24" cy="16" r="10" fill="white"/>
            <path d="M19 16l4-4 4 4-4 4z" fill="#2E7D32"/>
            <text x="24" y="52" text-anchor="middle" font-size="10" fill="#2E7D32" font-weight="bold">Ï∂úÎ∞úÏßÄ</text>
          </svg>
        `;
        break;
      case 'end':
        markerSvg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="48" height="60" viewBox="0 0 48 60">
            <defs>
              <linearGradient id="endGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#EF5350;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#C62828;stop-opacity:1" />
              </linearGradient>
              <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="4" stdDeviation="4" flood-color="rgba(0,0,0,0.3)"/>
              </filter>
            </defs>
            <path d="M24 0C15.163 0 8 7.163 8 16c0 12 16 28 16 28s16-16 16-28c0-8.837-7.163-16-16-16z" 
                  fill="url(#endGradient)" filter="url(#shadow)"/>
            <circle cx="24" cy="16" r="10" fill="white"/>
            <rect x="20" y="12" width="8" height="8" fill="#C62828"/>
            <text x="24" y="52" text-anchor="middle" font-size="10" fill="#C62828" font-weight="bold">ÎèÑÏ∞©ÏßÄ</text>
          </svg>
        `;
        break;
      case 'waypoint':
        const waypointNumber = waypointsRef.current.length;
        markerSvg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="48" height="60" viewBox="0 0 48 60">
            <defs>
              <linearGradient id="waypointGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#FFA726;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#E65100;stop-opacity:1" />
              </linearGradient>
              <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="4" stdDeviation="4" flood-color="rgba(0,0,0,0.3)"/>
              </filter>
            </defs>
            <path d="M24 0C15.163 0 8 7.163 8 16c0 12 16 28 16 28s16-16 16-28c0-8.837-7.163-16-16-16z" 
                  fill="url(#waypointGradient)" filter="url(#shadow)"/>
            <circle cx="24" cy="16" r="10" fill="white"/>
            <text x="24" y="21" text-anchor="middle" font-size="12" fill="#E65100" font-weight="bold">${waypointNumber}</text>
            <text x="24" y="52" text-anchor="middle" font-size="10" fill="#E65100" font-weight="bold">Í≤ΩÏú†ÏßÄ</text>
          </svg>
        `;
        break;
    }

    const imageSrc = 'data:image/svg+xml;base64,' + utf8ToBase64(markerSvg);

    const imageSize = new (window as any).kakao.maps.Size(48, 60);
    const markerImage = new (window as any).kakao.maps.MarkerImage(imageSrc, imageSize);

    const marker = new (window as any).kakao.maps.Marker({
      position,
      image: markerImage,
      map: mapInstance.current
    });

    routeMarkersRef.current.push(marker);
    console.log(`${type} ÎßàÏª§ Ï∂îÍ∞Ä ÏôÑÎ£å. Ï¥ù Í≤ΩÎ°ú ÎßàÏª§ Ïàò:`, routeMarkersRef.current.length);
  };

  const clearRoute = () => {
    console.log('Í≤ΩÎ°ú Ï¥àÍ∏∞Ìôî ÏãúÏûë');

    // Í≤ΩÎ°ú ÎßàÏª§Îì§ Ï†úÍ±∞ (ÏïàÏ†ÑÏÑ± Ï≤¥ÌÅ¨)
    if (routeMarkersRef.current && routeMarkersRef.current.length > 0) {
      routeMarkersRef.current.forEach(marker => {
        if (marker && marker.setMap) {
          marker.setMap(null);
        }
      });
      routeMarkersRef.current = [];
    }

    // Í≤ΩÎ°ú Ìè¥Î¶¨ÎùºÏù∏ Ï†úÍ±∞
    if (routePolylineRef.current) {
      routePolylineRef.current.setMap(null);
      routePolylineRef.current = null;
    }

    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    startPointRef.current = null;
    endPointRef.current = null;
    waypointsRef.current = [];
    isRouteModeRef.current = false;

    setRouteState({
      startPoint: null,
      endPoint: null,
      isRouteMode: false,
      recommendedRoute: null
    });

    // Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå Î™©Î°ù Ï¥àÍ∏∞Ìôî
    setNearbyQuietPlaces([]);

    // ÎßàÏª§ Í∞ïÏ°∞ ÌëúÏãú Ï¥àÍ∏∞Ìôî
    try {
      resetMarkerHighlights();
    } catch (error) {
      console.warn('ÎßàÏª§ Í∞ïÏ°∞ ÌëúÏãú Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
    }

    console.log('Í≤ΩÎ°ú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
  };

  // ÎßàÏª§ Í∞ïÏ°∞ ÌëúÏãú Ï¥àÍ∏∞Ìôî
  const resetMarkerHighlights = () => {
    if (!markersRef.current || !Array.isArray(markersRef.current)) {
      console.warn('ÎßàÏª§ Î∞∞Ïó¥Ïù¥ Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏùå');
      return;
    }

    markersRef.current.forEach((marker, index) => {
      try {
        const place = markersPlacesRef.current?.[index];
        if (place && marker && marker.setImage) {
          // Í∏∞Ï°¥ createMarkerIcon Ìï®ÏàòÎ°ú ÏõêÎûò ÎîîÏûêÏù∏ Î≥µÏõê
          const originalIcon = createMarkerIcon(place.category || 'Í∏∞ÌÉÄ');
          marker.setImage(originalIcon);
        }
      } catch (error) {
        console.warn(`ÎßàÏª§ ${index} Ï¥àÍ∏∞Ìôî Ïã§Ìå®:`, error);
      }
    });
  };

  const drawQuietRoute = async (start: LatLng, end: LatLng, waypoints: LatLng[] = []) => {
    try {
      console.log('ü§´ Ï°∞Ïö©Ìïú Í≤ΩÎ°ú ÌÉêÏÉâ Ï§ë...', start, waypoints.length > 0 ? `‚Üí ${waypoints.length}Í∞ú Í≤ΩÏú†ÏßÄ ‚Üí` : '‚Üí', end);

      // Ï°∞Ïö©Ìïú Í≤ΩÎ°ú APIÎ°ú ÏµúÏ†ÅÌôîÎêú Í≤ΩÎ°ú Í∞ÄÏ†∏Ïò§Í∏∞ (Í≤ΩÏú†ÏßÄ Ìè¨Ìï®)
      const routeData = await quietRouteApi.findQuietRoute(start, end, {
        preferQuiet: true,
        avoidCrowded: true,
        maxDetour: 500
      }, waypoints);

      console.log('üìç Ï°∞Ïö©Ìïú Í≤ΩÎ°ú Îç∞Ïù¥ÌÑ∞:', routeData);

      // Í≤ΩÎ°ú Ï¢åÌëúÎì§ÏùÑ Ïπ¥Ïπ¥Ïò§Îßµ LatLng Í∞ùÏ≤¥Î°ú Î≥ÄÌôò
      const linePath = routeData.points.map(point =>
        new (window as any).kakao.maps.LatLng(point.lat, point.lng)
      );

      // Ï°∞Ïö©Ìï® Ï†êÏàòÏóê Îî∞Î•∏ ÏÉâÏÉÅ Í≤∞Ï†ï
      const quietnessScore = routeData.quietness_score || 0.7;
      const routeColor = quietnessScore > 0.8 ? '#4CAF50' : // Îß§Ïö∞ Ï°∞Ïö©Ìï® - ÎÖπÏÉâ
                        quietnessScore > 0.6 ? '#8BC34A' : // Ï°∞Ïö©Ìï® - Ïó∞ÎÖπÏÉâ
                        quietnessScore > 0.4 ? '#FFC107' : // Î≥¥ÌÜµ - ÎÖ∏ÎûÄÏÉâ
                        '#FF9800'; // ÏãúÎÅÑÎü¨ÏõÄ - Ï£ºÌô©ÏÉâ

      // Ìè¥Î¶¨ÎùºÏù∏ÏúºÎ°ú Í≤ΩÎ°ú Í∑∏Î¶¨Í∏∞
      const polyline = new (window as any).kakao.maps.Polyline({
        path: linePath,
        strokeWeight: 6,
        strokeColor: routeColor,
        strokeOpacity: 0.8,
        strokeStyle: 'solid'
      });

      polyline.setMap(mapInstance.current);
      routePolylineRef.current = polyline;

      // Í≤ΩÎ°ú Ï†ïÎ≥¥ ÌëúÏãú
      const distanceKm = (routeData.distance / 1000).toFixed(1);
      const durationMin = Math.ceil(routeData.duration / 60);
      const quietnessPercent = Math.round(quietnessScore * 100);

      console.log(`‚úÖ Ï°∞Ïö©Ìïú Í≤ΩÎ°ú ÏôÑÎ£å: ${distanceKm}km, ÏïΩ ${durationMin}Î∂Ñ, Ï°∞Ïö©Ìï® ${quietnessPercent}%`);

      // Í≤ΩÎ°ú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setRouteState(prev => ({
        ...prev,
        recommendedRoute: {
          id: `route_${Date.now()}`,
          distance: routeData.distance,
          duration: routeData.duration,
          points: routeData.points,
          quietness_score: quietnessScore,
          estimated_time: routeData.duration,
          congestion_levels: []
        }
      }));

      // Í≤ΩÎ°ú Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå Ï∞æÍ∏∞
      console.log('üìç Í≤ΩÎ°ú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏:', {
        points: routeData.points?.length || 0,
        places: places?.length || 0,
        searchRadius
      });

      const nearbyPlaces = findNearbyQuietPlaces(routeData.points, places, searchRadius);
      setNearbyQuietPlaces(nearbyPlaces);

      console.log('üéØ Ï£ºÎ≥Ä Ïû•ÏÜå ÏÑ§Ï†ï ÏôÑÎ£å:', nearbyPlaces.length);

      // ÎßàÏª§ Í∞ïÏ°∞ ÌëúÏãú (Ïï†ÎãàÎ©îÏù¥ÏÖò Ìè¨Ìï®)
      if (nearbyPlaces.length > 0) {
        console.log('üé¨ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë');
        highlightNearbyPlaces(nearbyPlaces);
      } else {
        console.log('‚ùå Ï£ºÎ≥Ä Ïû•ÏÜåÍ∞Ä ÏóÜÏñ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÉùÎûµ');
      }

      // ÏÇ¨Ïö©ÏûêÏóêÍ≤å Í≤ΩÎ°ú Ï†ïÎ≥¥ ÏïåÎ¶º
      const nearbyCount = nearbyPlaces.length;
      const radiusKm = (searchRadius / 1000).toFixed(1);
      showAlert('success', `ü§´ Ï°∞Ïö©Ìïú Í≤ΩÎ°ú Ï∞æÍ∏∞ ÏôÑÎ£å!\nÍ±∞Î¶¨: ${distanceKm}km, ÏãúÍ∞Ñ: ${durationMin}Î∂Ñ\nÏ°∞Ïö©Ìï® ÏßÄÏàò: ${quietnessPercent}%\nüèûÔ∏è Î∞òÍ≤Ω ${radiusKm}km ÎÇ¥ Ï°∞Ïö©Ìïú Ïû•ÏÜå: ${nearbyCount}Í∞ú`);

    } catch (error) {
      console.error('‚ùå Ï°∞Ïö©Ìïú Í≤ΩÎ°ú ÌÉêÏÉâ Ïã§Ìå®:', error);

      // Ïã§Ìå® Ïãú Í∏∞Î≥∏ Ïπ¥Ïπ¥Ïò§ Í≤ΩÎ°úÎ°ú Ìè¥Î∞±
      try {
        const fallbackRoute = await kakaoDirectionsApi.getWalkingRoute(start, end);
        const linePath = fallbackRoute.points.map(point =>
          new (window as any).kakao.maps.LatLng(point.lat, point.lng)
        );

        const polyline = new (window as any).kakao.maps.Polyline({
          path: linePath,
          strokeWeight: 4,
          strokeColor: '#FF9800',
          strokeOpacity: 0.6,
          strokeStyle: 'shortdash'
        });

        polyline.setMap(mapInstance.current);
        routePolylineRef.current = polyline;

        showAlert('error', 'Ï°∞Ïö©Ìïú Í≤ΩÎ°úÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ ÏùºÎ∞ò Í≤ΩÎ°úÎ•º ÌëúÏãúÌï©ÎãàÎã§.');

      } catch (fallbackError) {
        console.error('Ìè¥Î∞± Í≤ΩÎ°úÎèÑ Ïã§Ìå®:', fallbackError);
        showAlert('error', 'Í≤ΩÎ°úÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      }
    }
  };

  // Í≤ΩÎ°ú Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå Ï∞æÍ∏∞
  const findNearbyQuietPlaces = (routePoints: LatLng[], allPlaces: Spot[], maxDistance: number): Spot[] => {
    console.log('üîç Í≤ΩÎ°ú Ï£ºÎ≥Ä Ïû•ÏÜå Ï∞æÍ∏∞ ÏãúÏûë:');
    console.log('- Í≤ΩÎ°ú Ìè¨Ïù∏Ìä∏ Ïàò:', routePoints?.length || 0);
    console.log('- Ï†ÑÏ≤¥ Ïû•ÏÜå Ïàò:', allPlaces?.length || 0);
    console.log('- ÏµúÎåÄ Í±∞Î¶¨:', maxDistance, 'm');

    if (!routePoints || !allPlaces || routePoints.length === 0 || allPlaces.length === 0) {
      console.warn('‚ùå Í≤ΩÎ°ú Ìè¨Ïù∏Ìä∏ ÎòêÎäî Ïû•ÏÜå Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§');
      return [];
    }

    const nearbyPlaces: Spot[] = [];

    allPlaces.forEach((place, index) => {
      // API ÏùëÎãµÏóêÏÑú lat, lng ÌïÑÎìú ÏÇ¨Ïö© (latitude, longitudeÍ∞Ä ÏïÑÎãò)
      const placePoint = {
        lat: place.lat,
        lng: place.lng
      };

      console.log(`Ïû•ÏÜå ${index + 1}: ${place.name} (${placePoint.lat}, ${placePoint.lng})`);

      if (!placePoint.lat || !placePoint.lng) {
        console.warn(`‚ùå Ïû•ÏÜå ${place.name}Ïùò Ï¢åÌëúÍ∞Ä ÏóÜÏäµÎãàÎã§`);
        return;
      }

      // Í≤ΩÎ°úÏùò Í∞Å Ï†êÍ≥º Ïû•ÏÜå ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨ Í≥ÑÏÇ∞
      const distances = routePoints.map(routePoint => {
        const distance = calculateDistance(routePoint, placePoint);
        return distance;
      });

      const minDistance = Math.min(...distances);
      console.log(`- ÏµúÎã® Í±∞Î¶¨: ${(minDistance / 1000).toFixed(2)}km`);

      if (minDistance <= maxDistance) {
        nearbyPlaces.push(place);
        console.log(`‚úÖ Ìè¨Ìï®Îê®: ${place.name}`);
      } else {
        console.log(`‚ùå Ï†úÏô∏Îê®: ${place.name} (Í±∞Î¶¨: ${(minDistance / 1000).toFixed(2)}km > ${(maxDistance / 1000).toFixed(1)}km)`);
      }
    });

    console.log(`üèûÔ∏è Í≤ΩÎ°ú Ï£ºÎ≥Ä ${maxDistance/1000}km Ïù¥ÎÇ¥ Ï°∞Ïö©Ìïú Ïû•ÏÜå: ${nearbyPlaces.length}Í∞ú`);
    console.log('Ï∞æÏùÄ Ïû•ÏÜåÎì§:', nearbyPlaces.map(p => p.name));
    return nearbyPlaces;
  };

  // Í±∞Î¶¨ Í≥ÑÏÇ∞ Ìï®Ïàò ÌÖåÏä§Ìä∏
  const testDistanceCalculation = () => {
    // ÏÑúÏö∏ ÏãúÏ≤≠ (37.5665, 126.9780)Í≥º Í∞ïÎÇ®Ïó≠ (37.4979, 127.0276) ÏÇ¨Ïù¥ Í±∞Î¶¨
    // Ïã§Ï†ú Í±∞Î¶¨: ÏïΩ 9.6km
    const point1 = { lat: 37.5665, lng: 126.9780 };
    const point2 = { lat: 37.4979, lng: 127.0276 };
    const distance = calculateDistance(point1, point2);
    console.log(`üß™ Í±∞Î¶¨ Í≥ÑÏÇ∞ ÌÖåÏä§Ìä∏: ÏÑúÏö∏ÏãúÏ≤≠ ‚Üî Í∞ïÎÇ®Ïó≠ = ${(distance / 1000).toFixed(2)}km (ÏòàÏÉÅ: ~9.6km)`);

    // 3km ÌÖåÏä§Ìä∏: ÏÑúÏö∏ÏãúÏ≤≠ÏóêÏÑú 3km Î∞òÍ≤Ω
    const point3 = { lat: 37.5665 + 0.027, lng: 126.9780 }; // ÏïΩ 3km Î∂ÅÏ™Ω
    const distance3km = calculateDistance(point1, point3);
    console.log(`üß™ 3km ÌÖåÏä§Ìä∏: ${(distance3km / 1000).toFixed(2)}km (ÏòàÏÉÅ: ~3km)`);
  };

  // Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå ÎßàÏª§ Í∞ïÏ°∞ (Ïï†ÎãàÎ©îÏù¥ÏÖò Ìè¨Ìï®)
  const highlightNearbyPlaces = (nearbyPlaces: Spot[]) => {
    if (!markersRef.current || !Array.isArray(markersRef.current)) {
      console.warn('ÎßàÏª§ Î∞∞Ïó¥Ïù¥ Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏùå');
      return;
    }

    markersRef.current.forEach((marker, index) => {
      try {
        const place = markersPlacesRef.current?.[index];
        const isNearby = nearbyPlaces.some(nearbyPlace => nearbyPlace.id === place?.id);

        if (isNearby && marker && marker.setImage) {
          // Ïï†ÎãàÎ©îÏù¥ÏÖò Í∞ïÏ°∞ ÎßàÏª§ ÏÉùÏÑ±
          animateMarker(marker, index);
        }
      } catch (error) {
        console.warn(`ÎßàÏª§ ${index} Í∞ïÏ°∞ ÌëúÏãú Ïã§Ìå®:`, error);
      }
    });
  };

  // ÎßàÏª§ Í∞ïÏ°∞ Ìö®Í≥º - Í∏∞Ï°¥ Î¨ºÎ∞©Ïö∏ ÎîîÏûêÏù∏Ïóê Îπ®Í∞ÑÏÉâ ÌÖåÎëêÎ¶¨
  const animateMarker = (marker: any, index: number) => {
    const originalPlace = markersPlacesRef.current[index];
    if (!originalPlace) return;

    // Í∏∞Ï°¥ Î¨ºÎ∞©Ïö∏ ÎîîÏûêÏù∏Ïóê Îπ®Í∞ÑÏÉâ ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä
    const categoryConfig = {
      'Ïπ¥Ìéò': { emoji: '‚òï', color: '#FF6B9D' },
      'ÎèÑÏÑúÍ¥Ä': { emoji: 'üìö', color: '#4ECDC4' },
      'Í≥µÏõê': { emoji: 'üå≥', color: '#45B7D1' },
      'Í∏∞ÌÉÄ': { emoji: 'üìç', color: '#96CEB4' }
    };

    const config = categoryConfig[originalPlace.category as keyof typeof categoryConfig] || categoryConfig['Í∏∞ÌÉÄ'];

    const highlightSvg = `
      <svg width="60" height="75" viewBox="0 0 60 75" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="shadow${index}" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-color="rgba(0,0,0,0.3)"/>
          </filter>
        </defs>
        <path d="M30 5C16.193 5 5 16.193 5 30c0 22.5 25 40 25 40s25-17.5 25-40C55 16.193 43.807 5 30 5z" 
              fill="${config.color}" 
              stroke="#FF0000" 
              stroke-width="3"
              filter="url(#shadow${index})"/>
        <circle cx="30" cy="30" r="18" fill="white" opacity="0.9"/>
        <text x="30" y="38" text-anchor="middle" font-size="24" fill="${config.color}">${config.emoji}</text>
      </svg>
    `;

    const highlightImageSrc = 'data:image/svg+xml;base64,' + utf8ToBase64(highlightSvg);
    const imageSize = new (window as any).kakao.maps.Size(60, 75);
    const highlightImage = new (window as any).kakao.maps.MarkerImage(
      highlightImageSrc,
      imageSize,
      {
        offset: new (window as any).kakao.maps.Point(30, 75)
      }
    );

    marker.setImage(highlightImage);
  };

  // Í±∞Î¶¨ Í≥ÑÏÇ∞ Ìï®Ïàò
  const calculateDistance = (point1: LatLng, point2: LatLng): number => {
    const R = 6371e3; // ÏßÄÍµ¨ Î∞òÏßÄÎ¶Ñ (ÎØ∏ÌÑ∞)
    const œÜ1 = point1.lat * Math.PI / 180;
    const œÜ2 = point2.lat * Math.PI / 180;
    const ŒîœÜ = (point2.lat - point1.lat) * Math.PI / 180;
    const ŒîŒª = (point2.lng - point1.lng) * Math.PI / 180;

    const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  };

  const handlePinRegistration = async (data: {
    name: string;
    description: string;
    category: string;
    noiseLevel: number;
    rating: number;
    image_url?: string;
    isNoiseRecorded: boolean;
  }) => {
    try {
      await withLoading(async () => {
        // Ï°∞Ïö©Ìï® Ï†êÏàò Í≥ÑÏÇ∞ (ÏÜåÏùåÎèÑ Í∏∞Î∞ò)
        const quietRating = Math.max(10, Math.min(100, 100 - (data.noiseLevel - 20) * 1.5));

        const currentUser = api.auth.getCurrentUser();
        const spotData = {
          name: data.name,
          description: data.description,
          lat: pinModalData.lat,
          lng: pinModalData.lng,
          category: data.category,
          noise_level: data.noiseLevel,
          rating: data.rating,
          quiet_rating: Math.round(quietRating),
          is_noise_recorded: data.isNoiseRecorded,
          user_id: currentUser ? currentUser.id : 'anonymous',
          image_url: data.image_url || undefined
        };


        // API Ìò∏Ï∂ú - Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠
        const response = await api.spots.createSpot(spotData);

        return response;
      }, 'ÏâøÌîåÎ†àÏù¥Ïä§ Îì±Î°ù Ï§ë...');

      // ÏÑ±Í≥µ Ïãú Î™®Îã¨ Îã´Í∏∞
      setShowPinModal(false);

      // Ïä§Ìåü Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
      if (onSpotsUpdate) {
        onSpotsUpdate();
      }

    } catch (error) {
      console.error('Ïä§Ìåü Îì±Î°ù Ïã§Ìå®:', error);
      showAlert('error', 'Ïä§Ìåü Îì±Î°ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
    }
  };

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      <div id="map" ref={mapRef} style={{ width: '100%', height: '100%' }} />

      {/* Ïª®ÌÖçÏä§Ìä∏ Î©îÎâ¥ */}
      {contextMenu.visible && (
        <div
          style={{
            position: 'fixed',
            left: contextMenu.x,
            top: contextMenu.y,
            background: 'white',
            border: '1px solid #ccc',
            borderRadius: '8px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
            zIndex: 2000,
            minWidth: '120px',
            overflow: 'hidden'
          }}
          onClick={(e) => e.stopPropagation()}
        >
          <div
            style={{
              padding: '8px 12px',
              cursor: 'pointer',
              borderBottom: '1px solid #eee',
              fontSize: '14px'
            }}
            onClick={() => handleContextMenuAction('register')}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
          >
            üìç ÌïÄ Îì±Î°ù
          </div>

          <div
            style={{
              padding: '8px 12px',
              cursor: 'pointer',
              borderBottom: '1px solid #eee',
              fontSize: '14px'
            }}
            onClick={() => handleContextMenuAction('start')}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
          >
            üöÄ Ï∂úÎ∞úÏßÄ
          </div>

          <div
            style={{
              padding: '8px 12px',
              cursor: 'pointer',
              borderBottom: '1px solid #eee',
              fontSize: '14px'
            }}
            onClick={() => handleContextMenuAction('waypoint')}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
          >
            üîÑ Í≤ΩÏú†ÏßÄ
          </div>

          <div
            style={{
              padding: '8px 12px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onClick={() => handleContextMenuAction('end')}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
          >
            üèÅ ÎèÑÏ∞©ÏßÄ
          </div>

          <div
            style={{
              padding: '8px 12px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onClick={() => handleContextMenuAction('clear-route')}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
          >
            üóëÔ∏è Í≤ΩÎ°ú ÏßÄÏö∞Í∏∞
          </div>
        </div>
      )}

      <button
        onClick={moveToCurrentLocation}
        disabled={isLocating}
        style={{
          position: 'absolute',
          bottom: '20px',
          right: '20px',
          width: '50px',
          height: '50px',
          borderRadius: '50%',
          border: 'none',
          backgroundColor: '#fff',
          boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
          cursor: isLocating ? 'not-allowed' : 'pointer',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: '20px',
          zIndex: 1000,
          opacity: isLocating ? 0.6 : 1,
          transition: 'all 0.2s ease'
        }}
        title="ÎÇ¥ ÏúÑÏπòÎ°ú Ïù¥Îèô"
      >
        {isLocating ? '‚è≥' : 'üìç'}
      </button>

      {/* Toggle Button */}
      <div style={{
        position: 'absolute',
        top: '20px',
        right: '20px',
        zIndex: 1000
      }}>
        <button
          onClick={() => setShowCongestion(!showCongestion)}
          style={{
            padding: '10px 15px',
            backgroundColor: showCongestion ? '#FF6B35' : '#fff',
            color: showCongestion ? '#fff' : '#333',
            border: '1px solid #ccc',
            borderRadius: '6px',
            fontSize: '14px',
            fontWeight: 'bold',
            cursor: 'pointer',
            boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
            minWidth: '100px'
          }}
        >
          Ïã§ÏãúÍ∞Ñ ÌòºÏû°ÎèÑ {showCongestion ? 'ON' : 'OFF'}
        </button>
      </div>

      <PinRegistrationModal
        isOpen={showPinModal}
        onClose={() => setShowPinModal(false)}
        lat={pinModalData.lat}
        lng={pinModalData.lng}
        onAlert={showAlert}
        onSubmit={handlePinRegistration}
      />

      <Alert
        type={alert.type}
        message={alert.message}
        isOpen={alert.isOpen}
        onClose={closeAlert}
      />

      {/* Congestion Overlay */}
      {showCongestion && (
        <PlacePopulation
          map={mapInstance.current}
          congestionData={populationData.map(data => {
            return {
              lat: data.lat,
              lng: data.lng,
              population: data.population_max,
              noiseLevel: 0,
              congestLevel: data.congest_level,
              address: data.area_name,
              name: data.area_name
            };
          })}
        />
      )}

      {/* Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå Î™©Î°ù */}
      {nearbyQuietPlaces.length > 0 && (
        <div
          style={{
            position: 'absolute',
            top: '20px',
            right: '20px',
            background: 'white',
            borderRadius: '12px',
            boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
            padding: '16px',
            maxWidth: '320px',
            maxHeight: '500px',
            overflowY: 'auto',
            zIndex: 1000
          }}
        >
          <div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '12px'
          }}>
            <h3 style={{
              margin: '0',
              fontSize: '16px',
              fontWeight: 'bold',
              color: '#2E7D32',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }}>
              ü§´ Í≤ΩÎ°ú Ï£ºÎ≥Ä Ï°∞Ïö©Ìïú Ïû•ÏÜå (1km Ïù¥ÎÇ¥)
              <span style={{
                background: '#4CAF50',
                color: 'white',
                borderRadius: '12px',
                padding: '2px 8px',
                fontSize: '12px'
              }}>
                {nearbyQuietPlaces.length}Í∞ú
              </span>
            </h3>
          </div>

          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            {nearbyQuietPlaces.map((place) => {
              // Í≤ΩÎ°úÏôÄÏùò ÏµúÎã® Í±∞Î¶¨ Í≥ÑÏÇ∞
              const minDistance = routeState.recommendedRoute?.points ?
                Math.min(...routeState.recommendedRoute.points.map(routePoint =>
                  calculateDistance(routePoint, {
                    lat: place.lat,
                    lng: place.lng
                  })
                )) : 0;

              return (
                <div
                  key={place.id}
                  style={{
                    padding: '12px',
                    background: '#F1F8E9',
                    borderRadius: '8px',
                    border: '1px solid #C8E6C9',
                    cursor: 'pointer',
                    transition: 'all 0.2s ease',
                    position: 'relative'
                  }}
                  onClick={() => moveToSpot(place)}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = '#E8F5E8';
                    e.currentTarget.style.transform = 'translateY(-1px)';
                    e.currentTarget.style.boxShadow = '0 2px 8px rgba(76, 175, 80, 0.3)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = '#F1F8E9';
                    e.currentTarget.style.transform = 'translateY(0)';
                    e.currentTarget.style.boxShadow = 'none';
                  }}
                >
                  <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    marginBottom: '4px'
                  }}>
                    <div style={{
                      fontWeight: 'bold',
                      fontSize: '14px',
                      color: '#2E7D32'
                    }}>
                      {place.name}
                    </div>
                    <div style={{
                      background: '#4CAF50',
                      color: 'white',
                      borderRadius: '8px',
                      padding: '2px 6px',
                      fontSize: '10px',
                      fontWeight: 'bold'
                    }}>
                      {(minDistance / 1000).toFixed(1)}km
                    </div>
                  </div>
                  <div style={{
                    fontSize: '12px',
                    color: '#558B2F',
                    marginBottom: '6px',
                    lineHeight: '1.3'
                  }}>
                    {place.description}
                  </div>
                  <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    fontSize: '11px',
                    color: '#689F38'
                  }}>
                    <span>üëç {place.like_count || 0}</span>
                    <span>üìç ÌÅ¥Î¶≠ÌïòÏó¨ Ïù¥Îèô</span>
                  </div>
                </div>
              );
            })}
          </div>

          <div style={{
            marginTop: '12px',
            padding: '8px',
            background: '#E8F5E8',
            borderRadius: '6px',
            fontSize: '11px',
            color: '#558B2F',
            textAlign: 'center'
          }}>
            üí° Í≤ΩÎ°úÏóêÏÑú 1km Ïù¥ÎÇ¥Ïùò Ï°∞Ïö©Ìïú Ïû•ÏÜåÎì§ÏûÖÎãàÎã§
          </div>
        </div>
      )}
    </div>
  );
};

export default Map;
